网络编程的基本模型是Client/Server模型，也就是两个进程之间相互通信。
服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，连接成功后
，双方就可以通过网络套接字（Socket）进行通信。

1.BIO
	通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成
后，通过输出流返回应答给客户端，线程销毁。典型的一请求一应答通信模型。

缺点：缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问量呈1:1的正比关系，由于线程是Java虚拟机非常
宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，
并最终导致进程宕机或者僵死。



2.伪异步IO
	后端通过一个线程池来处理多个客户端的请求接入，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致
线程耗尽。
	将客户端的Socket封装成一个Task（该任务实现Runnable接口）投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程
对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源是可控的，无论多少个客户端并发访问，都不会
导致资源耗尽和宕机。

缺点：如果所有的可用线程都被故障服务器阻塞，那后续所有的I/O消息都将在队列中排队。由于线程池采用阻塞队列实现，当队列积满之后，后续
入队列的操作将被阻塞。由于前端只有一个Acceptor线程接收客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求消息将被决绝，
客户端会发生大量的连接超时。由于几乎所有的连接都超时，调用者会人为系统已经崩溃，无法接收新的请求消息。



3.NIO（Non-Block I/O）
与Socket和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞
和非阻塞两种模式。
	1.在NIO中加入Buffer对象，体现了新库与原I/O的一个重要区别，每一种Java基本类型（除Boolean）都对应有一种缓冲区
	2.通道Channel Channel是一个通道，可以通过它读取和写入数据，通道域流不同之处在于通道是双向的，流只是在一个方向上移动（一个流
	必须是InputStream或者OutputStream的子类），而且通道可以用于读、写或者同时用读写。
	3.多路复用器Selector 是Java NIO编程的基础，其提供选择已经就绪的任务的能力。Selector会不断地轮询注册在其上的Channel，如果某个
	Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪channel
	的集合，进行后续的I/O操作。

优点：
	1.客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞
	2.SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O通信线程就可以处理其他的链路，不需要同步等待这个链路可用。
	3.线程模型的优化：由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者
	单个进程的句柄限制），这意味着一个Selector线程可以同时处理成千上万客户端连接，而且性能不会随着客户端的增加而线性下降，因此，
	它非常适合做高性能、高负载的网络服务器。



4.AIO
	NIO2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取操作结果。
	1.通过java.util.concurrent.Future类来表示异步操作的结果
	2.在执行异步操作的时候传入一个java.nio.channels

	NIO2.0的异步套接字通道是真正的异步非阻塞I/O，它对应UNIX网络编程中的事件驱动I/O(AIO),它不需要通过多路复用器(Selector)对注册的
	通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。






什么是TCP Window?
	在讨论TCP Window的时候, 我们几乎总是指的是TCP Receive Window. 简单来说, TCP Receive Window是在TCP连接两端都有的缓冲区,
用于暂时保存到来的数据. 在这个缓冲区中的数据会被发送到应用程序中, 为新到来的数据腾出空间. 如果这个缓冲满了,
那么数据的接收方会警告发送方在缓冲去清空之前已经不能在收取更多的数据了. 这其中涉及到一些细节, 但那都是很基本的东西.
一般,设备会在TCP Header信息中通知对方当前它的TCPWindows的大小.

TCP Window如何影响性能?
在一个文件传输的时候, 数据从一台机器流向另一台. 数据接收方需要阻止它的TCP Window降为0, 意味着window填满了. 如果一个TCP Window
变为0了, 或者接近0了, 这就会警告数据发送方没有更多空间来接受更多数据了.文件传输会停止, 直到收到一个update说buffer已经清空了.
http://www.cnblogs.com/awpatp/archive/2013/02/17/2914152.html